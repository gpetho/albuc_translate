import logging
import re
from bs4 import BeautifulSoup
import os
import sys
import json

import google.generativeai as genai
import google.api_core.exceptions
from retrying import retry

GEMINI_MODELS = [
    'gemini-1.5-pro-002',
    'gemini-1.5-flash-002',
    'gemini-1.5-flash-8b',
]

MAX_ATTEMPTS = 5  # Maximum number of attempts to retry a failed generation

LOG_LEVEL = logging.INFO
# LOG_LEVEL = logging.ERROR

SYS_PROMPT = ("The following is a paragraph from a medieval Arabic medical treatise. "
              "Translate the paragraph into English, breaking it up into full sentences. "
              "Repeat the Arabic sentence, followed by its English translation. "
              "Repeat the part of the original text precisely, even if it contains misspellings. "
              "Do not add or remove anything. The paragraph might be as short as a title or an "
              "image caption. This is not a mistake, just translate it. "
              "Format the output as a JSON list, each element containing an Arabic "
              "sentence and its English translation, called 'ara' and 'eng' respectively.\n")

@retry(wait_exponential_multiplier=1000, wait_exponential_max=10000,
       stop_max_attempt_number=5)
def generate_content(model, prompt):
    try:
        response = model.generate_content(prompt)
        return response
    except google.api_core.exceptions.DeadlineExceeded as e:
        print(f"Deadline exceeded: {e}")
        raise


def clean_arabic(text):
    # This is a stub generated by ChatGPT, there is no guarantee it will work as expected.
    # Please verify and modify it if needed.

    # Remove diacritics (Arabic vowel marks)
    text = re.sub(r'[\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E8\u06EA-\u06ED]', '', text)

    # Remove punctuation and non-essential symbols
    text = re.sub(r'[^\w\u0600-\u06FF]', '', text)

    # Remove whitespace
    text = re.sub(r'\s+', '', text)

    return text


def split_response(response):
    """
    Process a text file containing Arabic text and English translations.
    Returns the header (first line), list of Arabic lines, and list of English translations.
    """
    arabic_lines = []
    english_lines = []

    line_pairs = re.split(r'\n\n+', response.text)

    for lp in line_pairs:
        try:
            ara, eng = lp.split('\n')
        except ValueError:
            continue
        arabic_lines.append(ara)
        english_lines.append(eng)

    return arabic_lines, english_lines


def main():
    genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

    logger = logging.getLogger(__name__)
    # log to file
    logging.basicConfig(filename='segment_paragraphs.log', level=LOG_LEVEL)

#    args = parse_args()
    with open(sys.argv[1], encoding='utf-8') as xml_file:
        xml_doc = xml_file.read()
        xml_doc = re.sub(r':\n<note.*?</note>\n', ':\n</p><p source="note">',
                         xml_doc)
        soup = BeautifulSoup(xml_doc, "xml")

    try:
        with open("Albucasis_Chirurgia_translation.txt", encoding='utf-8') as trans_file:
            all_translations = trans_file.read().splitlines()
    except FileNotFoundError:
        all_translations = []

    # Delete all note, lb and pb elements from soup.
    for note in soup.find_all('note'):
        note.decompose()
    for lb in soup.find_all('lb'):
        lb.decompose()
    for pb in soup.find_all('pb'):
        pb.decompose()

    for head in soup.find_all('head'):
        new_tag = soup.new_tag('p', type='head')
        new_tag.string = head.get_text(strip=True)
        head.replace_with(new_tag)

    para_counter = 1
    s_counter = 1

    for para in soup.body.find_all('p'):
        if para.get('id') is not None:
            para_counter += 1
            last_s = para.find_all('s')[-1]
            s_counter = int(last_s['id'][1:]) + 1
            continue

        print(f"Processing paragraph {para_counter}, sentence {s_counter}")

        assert s_counter == len(all_translations) + 1

        model = GEMINI_MODELS[0]

        # add id attribute to para element of format p001 etc.
        para['id'] = f'p{para_counter:03}'

        para_text = para.text
        para_text = re.sub(r'\s+', ' ', para_text)

        print("length of paragraph: ", len(para_text))

        logger.info(f"para: {para}, para_counter: {para_counter}, s_counter: {s_counter}")
#        print("para_text:", para_text)

        attempt = 0
        while True:
            gemini = genai.GenerativeModel(
                model,
                system_instruction=SYS_PROMPT,
            )

            try:
                response = generate_content(gemini, para_text)
            except Exception as e:
                logger.error(f"Gemini API error: {e}")
                if attempt < MAX_ATTEMPTS:
                    attempt += 1
                    logger.error(f"Retrying... {attempt}")
                    continue
                else:
                    break

            try:
                response.text
            except ValueError:
                logger.error(f"Response error: {response}")
                if attempt < MAX_ATTEMPTS:
                    attempt += 1
                    logger.error(f"Retrying... {attempt}")
                    print("Retrying... {attempt}")
                    continue
                else:
                    logger.error(f"Failed to get response from Gemini API: {response}")
                    sys.exit(f"Failed to get response from Gemini API on paragraph {para_counter}")

            try:
                trans_data = json.loads(response.text.replace("```json", "").replace("```", ""))
            except json.decoder.JSONDecodeError:
                logger.error(f"Model failed to return JSON: {response.text}")
                if attempt < MAX_ATTEMPTS:
                    attempt += 1
                else:
                    if model == GEMINI_MODELS[0]:
                        model = GEMINI_MODELS[1]
                        attempt = 0
                    elif model == GEMINI_MODELS[1]:
                        model = GEMINI_MODELS[2]
                        attempt = 0
                    else:
                        sys.exit(f"Failed to get response from Gemini API on paragraph {para_counter}")
                continue

            arabic_lines = []
            english_lines = []

            for line in trans_data:
                arabic_lines.append(line['ara'])
                english_lines.append(line['eng'])

            with open("input.txt", "w", encoding='utf-8') as infile:
                print(para_text.replace("،", ""), file=infile)

            with open("output.txt", "w", encoding='utf-8') as outfile:
                print(' '.join(arabic_lines).replace("،", ""), file=outfile)

            joined_clean = ''.join(clean_arabic(line) for line in arabic_lines).replace('،', '')
            para_clean = clean_arabic(para_text.replace('،', ''))

            logger.info(f"arabic_lines: {arabic_lines}")
            logger.info(f"no. arabic lines: {len(arabic_lines)}")
            logger.info(f"total length of arabic lines: {len(' '.join(arabic_lines))}")
            logger.info(f"total length of input para: {len(para_text)}")
            logger.info(f"cleaned length of arabic lines: {len(joined_clean)}")
            logger.info(f"cleaned length of input para: {len(para_clean)}")

            if joined_clean == para_clean:
                print("Success, arabic lines match input paragraph, writing XML")
                break
            else:
                print(f"Arabic lines do not match input paragraph, retrying {attempt}")
                attempt += 1
            
            if attempt == MAX_ATTEMPTS:
                if model == GEMINI_MODELS[0]:
                    model = GEMINI_MODELS[1]
                    attempt = 0
                elif model == GEMINI_MODELS[1]:
                    model = GEMINI_MODELS[2]
                    attempt = 0
                else:
                    sys.exit(f"Failed to get response from Gemini API on paragraph {para_counter}")

        # delete all content from para element
        para.clear()
        for ara, eng in zip(arabic_lines, english_lines):
            all_translations.append(f"{ara}\t{eng}")
            with open("Albucasis_Chirurgia_translation.txt", "w", encoding='utf-8') as out:
                print("\n".join(all_translations), file=out)
            # create s element using BeautifulSoup with id attribute of format s001 etc.
            s = BeautifulSoup(f'<s id="s{s_counter:04}">{ara}</s>', 'xml')
            # insert a line break after each sentence element
            s.append("\n")
            para.append(s)
            s_counter += 1

        para_counter += 1

        # write segmented output so far to file
        with open("Albucasis_Chirurgia_ar_sentences.xml", "w", encoding='utf-8') as outfile:
            print(soup, file=outfile)


if __name__ == '__main__':
    main()
